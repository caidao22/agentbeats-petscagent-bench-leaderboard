{
  "agent": "019bc7e4-c94c-7f73-86a3-edb2d6affc73",
  "summary": {
    "total": 6,
    "runs_count": 3,
    "failure_count": 3,
    "avg_time_sec": 11.373245676358541,
    "avg_composite_score": 25.955354100302046,
    "tier_distribution": {
      "GOLD": 0,
      "SILVER": 1,
      "BRONZE": 0,
      "FAIL": 5
    }
  },
  "results": [
    {
      "problem_name": "Rosenbrock_banana_function",
      "problem_id": "3",
      "runs": false,
      "time_used_sec": 7.6785829067230225,
      "compiles": false,
      "stdout": null,
      "stderr": null,
      "cli_args": "-tao_monitor -tao_gatol 1e-8",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic Rosenbrock_banana_function.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o Rosenbrock_banana_function\n",
      "compile_stderr": "Rosenbrock_banana_function.c:1:138: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                          ^\nRosenbrock_banana_function.c:1:140: error: stray \u2018#\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                            ^\nRosenbrock_banana_function.c:1:139: error: unknown type name \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                           ^\nRosenbrock_banana_function.c:1:149: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018<\u2019 token\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                     ^\nRosenbrock_banana_function.c:1:161: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                 ^\nRosenbrock_banana_function.c:1:163: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:235: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:237: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                             ^\nRosenbrock_banana_function.c:1:236: error: unknown type name \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                            ^\nRosenbrock_banana_function.c:1:246: error: expected \u2018;\u2019 before \u2018struct\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                      ^~~~~~~\n      |                                                                                                                                                                                                                                                      ;\nRosenbrock_banana_function.c:1:255: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:256: error: unknown type name \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                ^\nRosenbrock_banana_function.c:1:268: error: expected \u2018:\u2019, \u2018,\u2019, \u2018;\u2019, \u2018}\u2019 or \u2018__attribute__\u2019 before \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                            ^\nRosenbrock_banana_function.c:1:270: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:281: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:283: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:282: error: unknown type name \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                          ^\nRosenbrock_banana_function.c:1:300: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018FormFunctionGradient\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                            ^~~~~~~~~~~~~~~~~~~~\nRosenbrock_banana_function.c:1:370: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                  ^\nRosenbrock_banana_function.c:1:395: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:420: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                    ^\nRosenbrock_banana_function.c:1:449: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^\nRosenbrock_banana_function.c:1:451: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:478: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:516: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^\nRosenbrock_banana_function.c:1:550: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:552: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^\nRosenbrock_banana_function.c:1:566: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:580: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^\nRosenbrock_banana_function.c:1:582: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:623: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:689: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^\nRosenbrock_banana_function.c:1:691: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:730: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\nRosenbrock_banana_function.c:1:794: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\nRosenbrock_banana_function.c:1:822: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:861: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^\nRosenbrock_banana_function.c:1:863: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:905: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:943: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:982: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:985: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:987: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:986: error: unknown type name \u2018n\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\nRosenbrock_banana_function.c:1:993: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018main\u2019\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^~~~\nRosenbrock_banana_function.c:1:1022: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1049: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:1074: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^\nRosenbrock_banana_function.c:1:1102: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1104: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\nRosenbrock_banana_function.c:1:1166: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1181: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^\nRosenbrock_banana_function.c:1:1183: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:1215: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^\nRosenbrock_banana_function.c:1:1272: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^\nRosenbrock_banana_function.c:1:1299: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:1329: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^\nRosenbrock_banana_function.c:1:1331: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:1358: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1406: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1446: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:1484: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\nRosenbrock_banana_function.c:1:1486: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1550: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1632: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\nRosenbrock_banana_function.c:1:1634: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^\nRosenbrock_banana_function.c:1:1686: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:1724: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\nRosenbrock_banana_function.c:1:1726: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\nRosenbrock_banana_function.c:1:1753: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:1782: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^\nRosenbrock_banana_function.c:1:1784: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^\nRosenbrock_banana_function.c:1:1811: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^\nRosenbrock_banana_function.c:1:1877: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\nRosenbrock_banana_function.c:1:1929: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\nRosenbrock_banana_function.c:1:1931: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:1949: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^\nRosenbrock_banana_function.c:1:1981: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^\nRosenbrock_banana_function.c:1:2011: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\nRosenbrock_banana_function.c:1:2042: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\nRosenbrock_banana_function.c:1:2055: error: stray \u2018\\\u2019 in program\n    1 | /* 2D Rosenbrock Function Optimization using PETSc/Tao \\n f(x,y) = (1-x)^2 + 100*(y-x^2)^2 \\n Global minimum is at (1,1) with f(x,y)=0 */\\n#include <petsctao.h>\\n\\nstatic char help[] = \"Solves the 2D Rosenbrock function using Tao.\\n\";\\n\\ntypedef struct {\\n  PetscInt n;\\n} AppCtx;\\n\\nPetscErrorCode FormFunctionGradient(Tao tao, Vec X, PetscReal *f, Vec G, void *ptr) {\\n  const PetscScalar *x;\\n  PetscScalar       *g;\\n  PetscReal         x1, x2;\\n\\n  PetscFunctionBeginUser;\\n  PetscCall(VecGetArrayRead(X, &x));\\n  PetscCall(VecGetArray(G, &g));\\n\\n  x1 = x[0];\\n  x2 = x[1];\\n\\n  /* f(x,y) = (1-x)^2 + 100(y-x^2)^2 */\\n  *f = PetscSqr(1.0 - x1) + 100.0 * PetscSqr(x2 - PetscSqr(x1));\\n\\n  /* df/dx = -2(1-x) - 400x(y-x^2) */\\n  g[0] = -2.0 * (1.0 - x1) - 400.0 * x1 * (x2 - PetscSqr(x1));\\n  /* df/dy = 200(y-x^2) */\\n  g[1] = 200.0 * (x2 - PetscSqr(x1));\\n\\n  PetscCall(VecRestoreArrayRead(X, &x));\\n  PetscCall(VecRestoreArray(G, &g));\\n  PetscFunctionReturn(PETSC_SUCCESS);\\n}\\n\\nint main(int argc, char **argv) {\\n  Tao                tao;\\n  Vec                x;\\n  AppCtx             user;\\n\\n  PetscCall(PetscInitialize(&argc, &argv, (char *)0, help));\\n  user.n = 2;\\n\\n  /* Create solution vector */\\n  PetscCall(VecCreateSeq(PETSC_COMM_SELF, user.n, &x));\\n  /* Set initial guess */\\n  PetscCall(VecSet(x, 0.0));\\n\\n  /* Create Tao solver */\\n  PetscCall(TaoCreate(PETSC_COMM_SELF, &tao));\\n  PetscCall(TaoSetType(tao, TAOLMVM));\\n  PetscCall(TaoSetSolution(tao, x));\\n\\n  /* Set objective function and gradient evaluation routine */\\n  PetscCall(TaoSetObjectiveAndGradient(tao, NULL, FormFunctionGradient, &user));\\n\\n  /* Check for any command line runtime options */\\n  PetscCall(TaoSetFromOptions(tao));\\n\\n  /* Solve the problem */\\n  PetscCall(TaoSolve(tao));\\n\\n  /* View the solution */\\n  PetscCall(PetscPrintf(PETSC_COMM_SELF, \"Final solution:\\\\n\"));\\n  PetscCall(VecView(x, PETSC_VIEWER_STDOUT_SELF));\\n\\n  /* Clean up */\\n  PetscCall(TaoDestroy(&tao));\\n  PetscCall(VecDestroy(&x));\\n  PetscCall(PetscFinalize());\\n  return 0;\\n}\n      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^\nmake: *** [/petsc/lib/petsc/conf/rules:218: Rosenbrock_banana_function] Error 1\n",
      "composite_score": 0.0,
      "tier": "FAIL",
      "category_scores": null,
      "evaluation_summary": {
        "error": "Exception with tool make: A nonzero returncode 2 from the tool"
      },
      "evaluation_details": null
    },
    {
      "problem_name": "Advection_PDE",
      "problem_id": "2",
      "runs": true,
      "time_used_sec": 6.228328227996826,
      "compiles": true,
      "stdout": "0 TS dt 0.001 time 0.\n1 TS dt 0.01 time 0.001\n2 TS dt 0.0300136 time 0.011\n3 TS dt 0.029903 time 0.0410136\n4 TS dt 0.0299501 time 0.0709167\n5 TS dt 0.0299956 time 0.100867\n6 TS dt 0.0300415 time 0.130862\n7 TS dt 0.0300878 time 0.160904\n8 TS dt 0.0301344 time 0.190992\n9 TS dt 0.0301814 time 0.221126\n10 TS dt 0.030228 time 0.251307\n11 TS dt 0.0298053 time 0.281535\n12 TS dt 0.0205565 time 0.297241\n13 TS dt 0.0167328 time 0.311174\n14 TS dt 0.0150077 time 0.324635\n15 TS dt 0.014028 time 0.337672\n16 TS dt 0.0129199 time 0.3517\n17 TS dt 0.0117584 time 0.36462\n18 TS dt 0.0120095 time 0.376379\n19 TS dt 0.0130642 time 0.388388\n20 TS dt 0.0133228 time 0.401452\n21 TS dt 0.0125747 time 0.414775\n22 TS dt 0.0120556 time 0.42735\n23 TS dt 0.0123653 time 0.439405\n24 TS dt 0.0129203 time 0.451771\n25 TS dt 0.0129049 time 0.464691\n26 TS dt 0.0124536 time 0.477596\n27 TS dt 0.0122537 time 0.490049\n28 TS dt 0.0124985 time 0.502303\n29 TS dt 0.0127672 time 0.514802\n30 TS dt 0.0126897 time 0.527569\n31 TS dt 0.0124439 time 0.540259\n32 TS dt 0.0123986 time 0.552702\n33 TS dt 0.0125768 time 0.565101\n34 TS dt 0.012703 time 0.577678\n35 TS dt 0.0126254 time 0.590381\n36 TS dt 0.0125056 time 0.603006\n37 TS dt 0.0125101 time 0.615512\n38 TS dt 0.012602 time 0.628022\n39 TS dt 0.0126333 time 0.640624\n40 TS dt 0.0125676 time 0.653257\n41 TS dt 0.0125067 time 0.665825\n42 TS dt 0.0125259 time 0.678332\n43 TS dt 0.0125822 time 0.690857\n44 TS dt 0.0126034 time 0.70344\n45 TS dt 0.0125759 time 0.716043\n46 TS dt 0.0125546 time 0.728619\n47 TS dt 0.0125783 time 0.741174\n48 TS dt 0.0126192 time 0.753752\n49 TS dt 0.0126212 time 0.766371\n50 TS dt 0.0125896 time 0.778992\n51 TS dt 0.0125727 time 0.791582\n52 TS dt 0.012584 time 0.804154\n53 TS dt 0.0125931 time 0.816739\n54 TS dt 0.0125777 time 0.829332\n55 TS dt 0.0125525 time 0.841909\n56 TS dt 0.0125428 time 0.854462\n57 TS dt 0.0125494 time 0.867005\n58 TS dt 0.0125526 time 0.879554\n59 TS dt 0.0125461 time 0.892107\n60 TS dt 0.012541 time 0.904653\n61 TS dt 0.0125442 time 0.917194\n62 TS dt 0.012551 time 0.929738\n63 TS dt 0.0125582 time 0.942289\n64 TS dt 0.0125621 time 0.954847\n65 TS dt 0.0125618 time 0.967409\n66 TS dt 0.0125622 time 0.979971\n67 TS dt 0.0125721 time 0.992533\n68 TS dt 0.0125806 time 1.00511\nVec Object: 1 MPI process\n  type: seq\n-0.0232505\n0.0289672\n0.079612\n0.131399\n0.181235\n0.231738\n0.280025\n0.328395\n0.374428\n0.419839\n0.462963\n0.504626\n0.54423\n0.581429\n0.616924\n0.649075\n0.67985\n0.706551\n0.731964\n0.752992\n0.772421\n0.787662\n0.800617\n0.809956\n0.816177\n0.819448\n0.818928\n0.815932\n0.808856\n0.799462\n0.786098\n0.770341\n0.750956\n0.729084\n0.703935\n0.676381\n0.645756\n0.613062\n0.577355\n0.540093\n0.499852\n0.458585\n0.414502\n0.369801\n0.322661\n0.275141\n0.225768\n0.176113\n0.125335\n0.074297\n0.0229263\n-0.0286803\n-0.0798649\n-0.131176\n-0.181433\n-0.231563\n-0.280178\n-0.328265\n-0.374529\n-0.419778\n-0.462974\n-0.504678\n-0.544103\n-0.581639\n-0.61663\n-0.649447\n-0.679414\n-0.707029\n-0.731472\n-0.753468\n-0.77199\n-0.788027\n-0.800331\n-0.810159\n-0.816053\n-0.819507\n-0.818916\n-0.815916\n-0.808885\n-0.799435\n-0.786118\n-0.770329\n-0.750964\n-0.72907\n-0.703967\n-0.676316\n-0.645866\n-0.612894\n-0.577588\n-0.539793\n-0.500214\n-0.458169\n-0.414957\n-0.369321\n-0.323149\n-0.274658\n-0.226232\n-0.175677\n-0.125737\n-0.073934\n",
      "stderr": "",
      "cli_args": "-ts_monitor",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic Advection_PDE.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o Advection_PDE\n",
      "compile_stderr": "",
      "composite_score": 42.79372723693053,
      "tier": "FAIL",
      "category_scores": {
        "correctness": 1.204271659319291e-12,
        "performance": 77.54334354400635,
        "code_quality": 80.17241379310346,
        "algorithm": 90.0,
        "petsc": 56.36363636363636
      },
      "evaluation_summary": {
        "total_evaluators": 14,
        "passed_evaluators": 11,
        "failed_evaluators": 3,
        "all_gates_passed": true,
        "gates_passed": 4,
        "gates_total": 4
      },
      "evaluation_details": [
        {
          "name": "compilation",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code compiled successfully"
        },
        {
          "name": "execution",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code executed successfully"
        },
        {
          "name": "memory_safety",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 0.7,
          "feedback": "Basic memory safety check (valgrind not available)"
        },
        {
          "name": "api_usage",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "All basic PETSc API requirements met"
        },
        {
          "name": "numerical_accuracy",
          "type": "metric",
          "method": "deterministic",
          "passed": false,
          "score": 1.2042716593192911e-14,
          "raw_value": 0.03205031634981692,
          "confidence": 1.0,
          "feedback": "Acceptable accuracy: error = 3.21e-02 (threshold: 1.00e-03)"
        },
        {
          "name": "execution_time",
          "type": "metric",
          "method": "deterministic",
          "passed": true,
          "score": 0.7754334354400635,
          "raw_value": 6.228328227996826,
          "confidence": 1.0,
          "feedback": "Acceptable performance: 6.228s (5.0s - 15.0s)"
        },
        {
          "name": "error_handling",
          "type": "quality",
          "method": "deterministic",
          "passed": false,
          "score": 0.3,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Poor error handling: only 0 CHKERRQ calls"
        },
        {
          "name": "parallel_awareness",
          "type": "quality",
          "method": "deterministic",
          "passed": true,
          "score": 0.85,
          "raw_value": null,
          "confidence": 0.8,
          "feedback": "Parallel features: Uses PETSC_COMM_WORLD, Parallel-aware sizing"
        },
        {
          "name": "readability",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.9,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The code is exceptionally clean and follows PETSc best practices for a simple 1D problem. It uses standard naming conventions and a logical structure that separates the physics (RHSFunction) from the solver setup (main)."
        },
        {
          "name": "code_style",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.8,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code is generally well-written and follows the core PETSc paradigms, such as using AppCtx for user data and the standard TS (Time-Stepper) workflow. However, it misses some idiomatic PETSc error handling and modern vector access patterns."
        },
        {
          "name": "documentation",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.7,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code is well-commented for a small script, clearly identifying the physics (1D Advection), the numerical scheme (Upwind), and the boundary conditions (Periodic). However, it lacks formal PETSc-style documentation headers for functions (e.g., documenting parameters and return values) and does not explain the 'AppCtx' struct members beyond simple inline notes. The main logic flow is clear, but more complex PETSc configurations like TSSetExactFinalTime are not explained for a novice user."
        },
        {
          "name": "algorithm_appropriateness",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.9,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The approach is highly appropriate for the problem requirements. Using PETSc's TS (Time Stepper) library is the standard way to solve time-dependent PDEs in this framework. The first-order upwind scheme is numerically stable for the advection equation (given c > 0) and correctly implements the requested periodic boundary conditions using the modulo operator. The choice of Runge-Kutta (TSRK) is a robust explicit method for this type of hyperbolic problem. The only minor limitation is that first-order upwind is highly diffusive, but it was specifically requested in the prompt."
        },
        {
          "name": "solver_choice",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.9,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The code correctly identifies TS (Time Stepper) as the appropriate PETSc module for a time-dependent PDE. It uses TSRK (Runge-Kutta), which is a standard and robust choice for hyperbolic problems like linear advection. The use of TSSetRHSFunction is appropriate for an explicit or semi-explicit formulation. While the problem is linear and could technically be solved with a linear TS (using TSSetRHSJacobian), the nonlinear interface (TSSetRHSFunction) is more flexible and commonly used in PETSc for such discretizations. The tolerances and time-stepping parameters are reasonable for a first-order upwind scheme."
        },
        {
          "name": "petsc_best_practices",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.6,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code correctly implements the basic TS (Time-Stepping) framework and uses appropriate array accessors (VecGetArrayRead). However, it violates several PETSc best practices for scalability and flexibility. It uses hardcoded values for 'n', 'dt', and 't_final' instead of allowing them to be set via PetscOptionsGetInt/Real. It lacks the use of DMDA (Distributed Arrays), which is the standard best practice for structured grids to handle ghost point communication and parallelization automatically. While it uses VecView, it defaults to STDOUT rather than allowing runtime-configurable file output. The use of M_PI is non-portable; PETSc provides PETSC_PI."
        }
      ]
    },
    {
      "problem_name": "DarcyFlow2D_Steady",
      "problem_id": "6",
      "runs": false,
      "time_used_sec": 19.90765404701233,
      "compiles": false,
      "stdout": null,
      "stderr": null,
      "cli_args": "-petscspace_degree 1 -dm_refine 4 -ksp_type cg -pc_type gamg",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic DarcyFlow2D_Steady.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o DarcyFlow2D_Steady\n",
      "compile_stderr": "DarcyFlow2D_Steady.c: In function \u2018main\u2019:\nDarcyFlow2D_Steady.c:50:3: error: unknown type name \u2018FEType\u2019; did you mean \u2018DMType\u2019?\n   50 |   FEType fe_type = PETSCFEBASIC;\n      |   ^~~~~~\n      |   DMType\nIn file included from /petsc/include/petscdmplex.h:11,\n                 from DarcyFlow2D_Steady.c:7:\n/petsc/include/petscfe.h:93:26: warning: initialization of \u2018int\u2019 from \u2018const char *\u2019 makes integer from pointer without a cast [-Wint-conversion]\n   93 | #define PETSCFEBASIC     \"basic\"\n      |                          ^~~~~~~\nDarcyFlow2D_Steady.c:50:20: note: in expansion of macro \u2018PETSCFEBASIC\u2019\n   50 |   FEType fe_type = PETSCFEBASIC;\n      |                    ^~~~~~~~~~~~\nDarcyFlow2D_Steady.c:52:3: error: unknown type name \u2018KSP\u2019\n   52 |   KSP ksp;\n      |   ^~~\nDarcyFlow2D_Steady.c:60:99: warning: passing argument 9 of \u2018DMPlexCreateBoxMesh\u2019 makes integer from pointer without a cast [-Wint-conversion]\n   60 |   ierr = DMPlexCreateBoxMesh(PETSC_COMM_WORLD, 2, PETSC_TRUE, NULL, NULL, NULL, NULL, PETSC_TRUE, &dm); CHKERRQ(ierr);\n      |                                                                                                   ^~~\n      |                                                                                                   |\n      |                                                                                                   struct _p_DM **\n/petsc/include/petscdmplex.h:181:171: note: expected \u2018PetscInt\u2019 {aka \u2018int\u2019} but argument is of type \u2018struct _p_DM **\u2019\n  181 | PETSC_EXTERN PetscErrorCode DMPlexCreateBoxMesh(MPI_Comm, PetscInt, PetscBool, const PetscInt[], const PetscReal[], const PetscReal[], const DMBoundaryType[], PetscBool, PetscInt, PetscBool, DM *);\n      |                                                                                                                                                                           ^~~~~~~~\nDarcyFlow2D_Steady.c:60:10: error: too few arguments to function \u2018DMPlexCreateBoxMesh\u2019\n   60 |   ierr = DMPlexCreateBoxMesh(PETSC_COMM_WORLD, 2, PETSC_TRUE, NULL, NULL, NULL, NULL, PETSC_TRUE, &dm); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~~~~~~~\n/petsc/include/petscdmplex.h:181:29: note: declared here\n  181 | PETSC_EXTERN PetscErrorCode DMPlexCreateBoxMesh(MPI_Comm, PetscInt, PetscBool, const PetscInt[], const PetscReal[], const PetscReal[], const DMBoundaryType[], PetscBool, PetscInt, PetscBool, DM *);\n      |                             ^~~~~~~~~~~~~~~~~~~\nDarcyFlow2D_Steady.c:72:53: warning: passing argument 4 of \u2018DMAddBoundary\u2019 from incompatible pointer type [-Wincompatible-pointer-types]\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |                                                     ^~~~~~~~\n      |                                                     |\n      |                                                     const char *\nIn file included from /petsc/include/petscdmplex.h:8:\n/petsc/include/petscdm.h:442:86: note: expected \u2018DMLabel\u2019 {aka \u2018struct _p_DMLabel *\u2019} but argument is of type \u2018const char *\u2019\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                                                                                      ^~~~~~~\nDarcyFlow2D_Steady.c:72:69: warning: passing argument 7 of \u2018DMAddBoundary\u2019 makes integer from pointer without a cast [-Wint-conversion]\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |                                                                     ^~~~\n      |                                                                     |\n      |                                                                     void *\n/petsc/include/petscdm.h:442:123: note: expected \u2018PetscInt\u2019 {aka \u2018int\u2019} but argument is of type \u2018void *\u2019\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                                                                                                                           ^~~~~~~~\nDarcyFlow2D_Steady.c:72:75: warning: passing argument 8 of \u2018DMAddBoundary\u2019 makes integer from pointer without a cast [-Wint-conversion]\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |                                                                           ^\n      |                                                                           |\n      |                                                                           void (*)(void)\n/petsc/include/petscdm.h:442:133: note: expected \u2018PetscInt\u2019 {aka \u2018int\u2019} but argument is of type \u2018void (*)(void)\u2019\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                                                                                                                                     ^~~~~~~~\nDarcyFlow2D_Steady.c:72:103: warning: passing argument 10 of \u2018DMAddBoundary\u2019 makes pointer from integer without a cast [-Wint-conversion]\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |                                                                                                       ^\n      |                                                                                                       |\n      |                                                                                                       int\n/petsc/include/petscdm.h:442:161: note: expected \u2018void (*)(void)\u2019 but argument is of type \u2018int\u2019\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                                                                                                                                                                 ^~~~~~~~~~~~~\nDarcyFlow2D_Steady.c:72:106: warning: passing argument 11 of \u2018DMAddBoundary\u2019 from incompatible pointer type [-Wincompatible-pointer-types]\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |                                                                                                          ^~~\n      |                                                                                                          |\n      |                                                                                                          PetscInt * {aka int *}\n/petsc/include/petscdm.h:442:176: note: expected \u2018void (*)(void)\u2019 but argument is of type \u2018PetscInt *\u2019 {aka \u2018int *\u2019}\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                                                                                                                                                                                ^~~~~~~~~~~~~\nDarcyFlow2D_Steady.c:72:10: error: too few arguments to function \u2018DMAddBoundary\u2019\n   72 |   ierr = DMAddBoundary(dm, DM_BC_ESSENTIAL, \"wall\", \"marker\", 0, 0, NULL, (void (*)(void))NULL, NULL, 4, ids, &user); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~\n/petsc/include/petscdm.h:442:29: note: declared here\n  442 | PETSC_EXTERN PetscErrorCode DMAddBoundary(DM, DMBoundaryConditionType, const char[], DMLabel, PetscInt, const PetscInt[], PetscInt, PetscInt, const PetscInt[], PetscVoidFn *, PetscVoidFn *, void *, PetscInt *);\n      |                             ^~~~~~~~~~~~~\nDarcyFlow2D_Steady.c:78:10: warning: implicit declaration of function \u2018DMPlexComputeResidualFEM\u2019; did you mean \u2018DMPlexSNESComputeResidualFEM\u2019? [-Wimplicit-function-declaration]\n   78 |   ierr = DMPlexComputeResidualFEM(dm, u, b, &user); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~\n      |          DMPlexSNESComputeResidualFEM\nDarcyFlow2D_Steady.c:80:10: warning: implicit declaration of function \u2018DMPlexComputeJacobianFEM\u2019; did you mean \u2018DMPlexTSComputeIJacobianFEM\u2019? [-Wimplicit-function-declaration]\n   80 |   ierr = DMPlexComputeJacobianFEM(dm, u, A, A, &user); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~\n      |          DMPlexTSComputeIJacobianFEM\nDarcyFlow2D_Steady.c:82:10: warning: implicit declaration of function \u2018KSPCreate\u2019; did you mean \u2018ISCreate\u2019? [-Wimplicit-function-declaration]\n   82 |   ierr = KSPCreate(PETSC_COMM_WORLD, &ksp); CHKERRQ(ierr);\n      |          ^~~~~~~~~\n      |          ISCreate\nDarcyFlow2D_Steady.c:83:10: warning: implicit declaration of function \u2018KSPSetOperators\u2019 [-Wimplicit-function-declaration]\n   83 |   ierr = KSPSetOperators(ksp, A, A); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~~~\nDarcyFlow2D_Steady.c:84:10: warning: implicit declaration of function \u2018KSPSetFromOptions\u2019; did you mean \u2018DMSetFromOptions\u2019? [-Wimplicit-function-declaration]\n   84 |   ierr = KSPSetFromOptions(ksp); CHKERRQ(ierr);\n      |          ^~~~~~~~~~~~~~~~~\n      |          DMSetFromOptions\nDarcyFlow2D_Steady.c:85:10: warning: implicit declaration of function \u2018KSPSolve\u2019 [-Wimplicit-function-declaration]\n   85 |   ierr = KSPSolve(ksp, b, u); CHKERRQ(ierr);\n      |          ^~~~~~~~\nDarcyFlow2D_Steady.c:91:10: warning: implicit declaration of function \u2018KSPDestroy\u2019; did you mean \u2018ISDestroy\u2019? [-Wimplicit-function-declaration]\n   91 |   ierr = KSPDestroy(&ksp); CHKERRQ(ierr);\n      |          ^~~~~~~~~~\n      |          ISDestroy\nDarcyFlow2D_Steady.c:50:10: warning: unused variable \u2018fe_type\u2019 [-Wunused-variable]\n   50 |   FEType fe_type = PETSCFEBASIC;\n      |          ^~~~~~~\nmake: *** [/petsc/lib/petsc/conf/rules:218: DarcyFlow2D_Steady] Error 1\n",
      "composite_score": 0.0,
      "tier": "FAIL",
      "category_scores": null,
      "evaluation_summary": {
        "error": "Exception with tool make: A nonzero returncode 2 from the tool"
      },
      "evaluation_details": null
    },
    {
      "problem_name": "Robertson_ODE",
      "problem_id": "1",
      "runs": true,
      "time_used_sec": 6.8150341510772705,
      "compiles": true,
      "stdout": "0 TS dt 0.0001 time 0.\n1 TS dt 0.0001 time 0.0001\n2 TS dt 0.0001 time 0.0002\n3 TS dt 0.0001 time 0.0003\n4 TS dt 0.0001 time 0.0004\n5 TS dt 0.0001 time 0.0005\n6 TS dt 0.0001 time 0.0006\n7 TS dt 0.0001 time 0.0007\n8 TS dt 0.0001 time 0.0008\n9 TS dt 0.0001 time 0.0009\n10 TS dt 0.0001 time 0.001\n11 TS dt 0.0001 time 0.0011\n12 TS dt 0.0001 time 0.0012\n13 TS dt 0.0001 time 0.0013\n14 TS dt 0.0001 time 0.0014\n15 TS dt 0.0001 time 0.0015\n16 TS dt 0.0001 time 0.0016\n17 TS dt 0.0001 time 0.0017\n18 TS dt 0.0001 time 0.0018\n19 TS dt 0.0001 time 0.0019\n20 TS dt 0.0001 time 0.002\n21 TS dt 0.0001 time 0.0021\n22 TS dt 0.0001 time 0.0022\n23 TS dt 0.0001 time 0.0023\n24 TS dt 0.0001 time 0.0024\n25 TS dt 0.0001 time 0.0025\n26 TS dt 0.0001 time 0.0026\n27 TS dt 0.0001 time 0.0027\n28 TS dt 0.0001 time 0.0028\n29 TS dt 0.0001 time 0.0029\n30 TS dt 0.0001 time 0.003\n31 TS dt 0.0001 time 0.0031\n32 TS dt 0.0001 time 0.0032\n33 TS dt 0.0001 time 0.0033\n34 TS dt 0.0001 time 0.0034\n35 TS dt 0.0001 time 0.0035\n36 TS dt 0.0001 time 0.0036\n37 TS dt 0.0001 time 0.0037\n38 TS dt 0.0001 time 0.0038\n39 TS dt 0.0001 time 0.0039\n40 TS dt 0.0001 time 0.004\n41 TS dt 0.0001 time 0.0041\n42 TS dt 0.0001 time 0.0042\n43 TS dt 0.0001 time 0.0043\n44 TS dt 0.0001 time 0.0044\n45 TS dt 0.0001 time 0.0045\n46 TS dt 0.0001 time 0.0046\n47 TS dt 0.0001 time 0.0047\n48 TS dt 0.0001 time 0.0048\n49 TS dt 0.0001 time 0.0049\n50 TS dt 0.0001 time 0.005\n51 TS dt 0.0001 time 0.0051\n52 TS dt 0.0001 time 0.0052\n53 TS dt 0.0001 time 0.0053\n54 TS dt 0.0001 time 0.0054\n55 TS dt 0.0001 time 0.0055\n56 TS dt 0.0001 time 0.0056\n57 TS dt 0.0001 time 0.0057\n58 TS dt 0.0001 time 0.0058\n59 TS dt 0.0001 time 0.0059\n60 TS dt 0.0001 time 0.006\n61 TS dt 0.0001 time 0.0061\n62 TS dt 0.0001 time 0.0062\n63 TS dt 0.0001 time 0.0063\n64 TS dt 0.0001 time 0.0064\n65 TS dt 0.0001 time 0.0065\n66 TS dt 0.0001 time 0.0066\n67 TS dt 0.0001 time 0.0067\n68 TS dt 0.0001 time 0.0068\n69 TS dt 0.0001 time 0.0069\n70 TS dt 0.0001 time 0.007\n71 TS dt 0.0001 time 0.0071\n72 TS dt 0.0001 time 0.0072\n73 TS dt 0.0001 time 0.0073\n74 TS dt 0.0001 time 0.0074\n75 TS dt 0.0001 time 0.0075\n76 TS dt 0.0001 time 0.0076\n77 TS dt 0.0001 time 0.0077\n78 TS dt 0.0001 time 0.0078\n79 TS dt 0.0001 time 0.0079\n80 TS dt 0.0001 time 0.008\n81 TS dt 0.0001 time 0.0081\n82 TS dt 0.0001 time 0.0082\n83 TS dt 0.0001 time 0.0083\n84 TS dt 0.0001 time 0.0084\n85 TS dt 0.0001 time 0.0085\n86 TS dt 0.0001 time 0.0086\n87 TS dt 0.0001 time 0.0087\n88 TS dt 0.0001 time 0.0088\n89 TS dt 0.0001 time 0.0089\n90 TS dt 0.0001 time 0.009\n91 TS dt 0.0001 time 0.0091\n92 TS dt 0.0001 time 0.0092\n93 TS dt 0.0001 time 0.0093\n94 TS dt 0.0001 time 0.0094\n95 TS dt 0.0001 time 0.0095\n96 TS dt 0.0001 time 0.0096\n97 TS dt 0.0001 time 0.0097\n98 TS dt 0.0001 time 0.0098\n99 TS dt 0.0001 time 0.0099\n100 TS dt 0.0001 time 0.01\n101 TS dt 0.0001 time 0.0101\n102 TS dt 0.0001 time 0.0102\n103 TS dt 0.0001 time 0.0103\n104 TS dt 0.0001 time 0.0104\n105 TS dt 0.0001 time 0.0105\n106 TS dt 0.0001 time 0.0106\n107 TS dt 0.0001 time 0.0107\n108 TS dt 0.0001 time 0.0108\n109 TS dt 0.0001 time 0.0109\n110 TS dt 0.0001 time 0.011\n111 TS dt 0.0001 time 0.0111\n112 TS dt 0.0001 time 0.0112\n113 TS dt 0.0001 time 0.0113\n114 TS dt 0.0001 time 0.0114\n115 TS dt 0.0001 time 0.0115\n116 TS dt 0.0001 time 0.0116\n117 TS dt 0.0001 time 0.0117\n118 TS dt 0.0001 time 0.0118\n119 TS dt 0.0001 time 0.0119\n120 TS dt 0.0001 time 0.012\n121 TS dt 0.0001 time 0.0121\n122 TS dt 0.0001 time 0.0122\n123 TS dt 0.0001 time 0.0123\n124 TS dt 0.0001 time 0.0124\n125 TS dt 0.0001 time 0.0125\n126 TS dt 0.0001 time 0.0126\n127 TS dt 0.0001 time 0.0127\n128 TS dt 0.0001 time 0.0128\n129 TS dt 0.0001 time 0.0129\n130 TS dt 0.0001 time 0.013\n131 TS dt 0.0001 time 0.0131\n132 TS dt 0.0001 time 0.0132\n133 TS dt 0.0001 time 0.0133\n134 TS dt 0.0001 time 0.0134\n135 TS dt 0.0001 time 0.0135\n136 TS dt 0.0001 time 0.0136\n137 TS dt 0.0001 time 0.0137\n138 TS dt 0.0001 time 0.0138\n139 TS dt 0.0001 time 0.0139\n140 TS dt 0.0001 time 0.014\n141 TS dt 0.0001 time 0.0141\n142 TS dt 0.0001 time 0.0142\n143 TS dt 0.0001 time 0.0143\n144 TS dt 0.0001 time 0.0144\n145 TS dt 0.0001 time 0.0145\n146 TS dt 0.0001 time 0.0146\n147 TS dt 0.0001 time 0.0147\n148 TS dt 0.0001 time 0.0148\n149 TS dt 0.0001 time 0.0149\n150 TS dt 0.0001 time 0.015\n151 TS dt 0.0001 time 0.0151\n152 TS dt 0.0001 time 0.0152\n153 TS dt 0.0001 time 0.0153\n154 TS dt 0.0001 time 0.0154\n155 TS dt 0.0001 time 0.0155\n156 TS dt 0.0001 time 0.0156\n157 TS dt 0.0001 time 0.0157\n158 TS dt 0.0001 time 0.0158\n159 TS dt 0.0001 time 0.0159\n160 TS dt 0.0001 time 0.016\n161 TS dt 0.0001 time 0.0161\n162 TS dt 0.0001 time 0.0162\n163 TS dt 0.0001 time 0.0163\n164 TS dt 0.0001 time 0.0164\n165 TS dt 0.0001 time 0.0165\n166 TS dt 0.0001 time 0.0166\n167 TS dt 0.0001 time 0.0167\n168 TS dt 0.0001 time 0.0168\n169 TS dt 0.0001 time 0.0169\n170 TS dt 0.0001 time 0.017\n171 TS dt 0.0001 time 0.0171\n172 TS dt 0.0001 time 0.0172\n173 TS dt 0.0001 time 0.0173\n174 TS dt 0.0001 time 0.0174\n175 TS dt 0.0001 time 0.0175\n176 TS dt 0.0001 time 0.0176\n177 TS dt 0.0001 time 0.0177\n178 TS dt 0.0001 time 0.0178\n179 TS dt 0.0001 time 0.0179\n180 TS dt 0.0001 time 0.018\n181 TS dt 0.0001 time 0.0181\n182 TS dt 0.0001 time 0.0182\n183 TS dt 0.0001 time 0.0183\n184 TS dt 0.0001 time 0.0184\n185 TS dt 0.0001 time 0.0185\n186 TS dt 0.0001 time 0.0186\n187 TS dt 0.0001 time 0.0187\n188 TS dt 0.0001 time 0.0188\n189 TS dt 0.0001 time 0.0189\n190 TS dt 0.0001 time 0.019\n191 TS dt 0.0001 time 0.0191\n192 TS dt 0.0001 time 0.0192\n193 TS dt 0.0001 time 0.0193\n194 TS dt 0.0001 time 0.0194\n195 TS dt 0.0001 time 0.0195\n196 TS dt 0.0001 time 0.0196\n197 TS dt 0.0001 time 0.0197\n198 TS dt 0.0001 time 0.0198\n199 TS dt 0.0001 time 0.0199\n200 TS dt 0.0001 time 0.02\n201 TS dt 0.0001 time 0.0201\n202 TS dt 0.0001 time 0.0202\n203 TS dt 0.0001 time 0.0203\n204 TS dt 0.0001 time 0.0204\n205 TS dt 0.0001 time 0.0205\n206 TS dt 0.0001 time 0.0206\n207 TS dt 0.0001 time 0.0207\n208 TS dt 0.0001 time 0.0208\n209 TS dt 0.0001 time 0.0209\n210 TS dt 0.0001 time 0.021\n211 TS dt 0.0001 time 0.0211\n212 TS dt 0.0001 time 0.0212\n213 TS dt 0.0001 time 0.0213\n214 TS dt 0.0001 time 0.0214\n215 TS dt 0.0001 time 0.0215\n216 TS dt 0.0001 time 0.0216\n217 TS dt 0.0001 time 0.0217\n218 TS dt 0.0001 time 0.0218\n219 TS dt 0.0001 time 0.0219\n220 TS dt 0.0001 time 0.022\n221 TS dt 0.0001 time 0.0221\n222 TS dt 0.0001 time 0.0222\n223 TS dt 0.0001 time 0.0223\n224 TS dt 0.0001 time 0.0224\n225 TS dt 0.0001 time 0.0225\n226 TS dt 0.0001 time 0.0226\n227 TS dt 0.0001 time 0.0227\n228 TS dt 0.0001 time 0.0228\n229 TS dt 0.0001 time 0.0229\n230 TS dt 0.0001 time 0.023\n231 TS dt 0.0001 time 0.0231\n232 TS dt 0.0001 time 0.0232\n233 TS dt 0.0001 time 0.0233\n234 TS dt 0.0001 time 0.0234\n235 TS dt 0.0001 time 0.0235\n236 TS dt 0.0001 time 0.0236\n237 TS dt 0.0001 time 0.0237\n238 TS dt 0.0001 time 0.0238\n239 TS dt 0.0001 time 0.0239\n240 TS dt 0.0001 time 0.024\n241 TS dt 0.0001 time 0.0241\n242 TS dt 0.0001 time 0.0242\n243 TS dt 0.0001 time 0.0243\n244 TS dt 0.0001 time 0.0244\n245 TS dt 0.0001 time 0.0245\n246 TS dt 0.0001 time 0.0246\n247 TS dt 0.0001 time 0.0247\n248 TS dt 0.0001 time 0.0248\n249 TS dt 0.0001 time 0.0249\n250 TS dt 0.0001 time 0.025\n251 TS dt 0.0001 time 0.0251\n252 TS dt 0.0001 time 0.0252\n253 TS dt 0.0001 time 0.0253\n254 TS dt 0.0001 time 0.0254\n255 TS dt 0.0001 time 0.0255\n256 TS dt 0.0001 time 0.0256\n257 TS dt 0.0001 time 0.0257\n258 TS dt 0.0001 time 0.0258\n259 TS dt 0.0001 time 0.0259\n260 TS dt 0.0001 time 0.026\n261 TS dt 0.0001 time 0.0261\n262 TS dt 0.0001 time 0.0262\n263 TS dt 0.0001 time 0.0263\n264 TS dt 0.0001 time 0.0264\n265 TS dt 0.0001 time 0.0265\n266 TS dt 0.0001 time 0.0266\n267 TS dt 0.0001 time 0.0267\n268 TS dt 0.0001 time 0.0268\n269 TS dt 0.0001 time 0.0269\n270 TS dt 0.0001 time 0.027\n271 TS dt 0.0001 time 0.0271\n272 TS dt 0.0001 time 0.0272\n273 TS dt 0.0001 time 0.0273\n274 TS dt 0.0001 time 0.0274\n275 TS dt 0.0001 time 0.0275\n276 TS dt 0.0001 time 0.0276\n277 TS dt 0.0001 time 0.0277\n278 TS dt 0.0001 time 0.0278\n279 TS dt 0.0001 time 0.0279\n280 TS dt 0.0001 time 0.028\n281 TS dt 0.0001 time 0.0281\n282 TS dt 0.0001 time 0.0282\n283 TS dt 0.0001 time 0.0283\n284 TS dt 0.0001 time 0.0284\n285 TS dt 0.0001 time 0.0285\n286 TS dt 0.0001 time 0.0286\n287 TS dt 0.0001 time 0.0287\n288 TS dt 0.0001 time 0.0288\n289 TS dt 0.0001 time 0.0289\n290 TS dt 0.0001 time 0.029\n291 TS dt 0.0001 time 0.0291\n292 TS dt 0.0001 time 0.0292\n293 TS dt 0.0001 time 0.0293\n294 TS dt 0.0001 time 0.0294\n295 TS dt 0.0001 time 0.0295\n296 TS dt 0.0001 time 0.0296\n297 TS dt 0.0001 time 0.0297\n298 TS dt 0.0001 time 0.0298\n299 TS dt 0.0001 time 0.0299\n300 TS dt 0.0001 time 0.03\n301 TS dt 0.0001 time 0.0301\n302 TS dt 0.0001 time 0.0302\n303 TS dt 0.0001 time 0.0303\n304 TS dt 0.0001 time 0.0304\n305 TS dt 0.0001 time 0.0305\n306 TS dt 0.0001 time 0.0306\n307 TS dt 0.0001 time 0.0307\n308 TS dt 0.0001 time 0.0308\n309 TS dt 0.0001 time 0.0309\n310 TS dt 0.0001 time 0.031\n311 TS dt 0.0001 time 0.0311\n312 TS dt 0.0001 time 0.0312\n313 TS dt 0.0001 time 0.0313\n314 TS dt 0.0001 time 0.0314\n315 TS dt 0.0001 time 0.0315\n316 TS dt 0.0001 time 0.0316\n317 TS dt 0.0001 time 0.0317\n318 TS dt 0.0001 time 0.0318\n319 TS dt 0.0001 time 0.0319\n320 TS dt 0.0001 time 0.032\n321 TS dt 0.0001 time 0.0321\n322 TS dt 0.0001 time 0.0322\n323 TS dt 0.0001 time 0.0323\n324 TS dt 0.0001 time 0.0324\n325 TS dt 0.0001 time 0.0325\n326 TS dt 0.0001 time 0.0326\n327 TS dt 0.0001 time 0.0327\n328 TS dt 0.0001 time 0.0328\n329 TS dt 0.0001 time 0.0329\n330 TS dt 0.0001 time 0.033\n331 TS dt 0.0001 time 0.0331\n332 TS dt 0.0001 time 0.0332\n333 TS dt 0.0001 time 0.0333\n334 TS dt 0.0001 time 0.0334\n335 TS dt 0.0001 time 0.0335\n336 TS dt 0.0001 time 0.0336\n337 TS dt 0.0001 time 0.0337\n338 TS dt 0.0001 time 0.0338\n339 TS dt 0.0001 time 0.0339\n340 TS dt 0.0001 time 0.034\n341 TS dt 0.0001 time 0.0341\n342 TS dt 0.0001 time 0.0342\n343 TS dt 0.0001 time 0.0343\n344 TS dt 0.0001 time 0.0344\n345 TS dt 0.0001 time 0.0345\n346 TS dt 0.0001 time 0.0346\n347 TS dt 0.0001 time 0.0347\n348 TS dt 0.0001 time 0.0348\n349 TS dt 0.0001 time 0.0349\n350 TS dt 0.0001 time 0.035\n351 TS dt 0.0001 time 0.0351\n352 TS dt 0.0001 time 0.0352\n353 TS dt 0.0001 time 0.0353\n354 TS dt 0.0001 time 0.0354\n355 TS dt 0.0001 time 0.0355\n356 TS dt 0.0001 time 0.0356\n357 TS dt 0.0001 time 0.0357\n358 TS dt 0.0001 time 0.0358\n359 TS dt 0.0001 time 0.0359\n360 TS dt 0.0001 time 0.036\n361 TS dt 0.0001 time 0.0361\n362 TS dt 0.0001 time 0.0362\n363 TS dt 0.0001 time 0.0363\n364 TS dt 0.0001 time 0.0364\n365 TS dt 0.0001 time 0.0365\n366 TS dt 0.0001 time 0.0366\n367 TS dt 0.0001 time 0.0367\n368 TS dt 0.0001 time 0.0368\n369 TS dt 0.0001 time 0.0369\n370 TS dt 0.0001 time 0.037\n371 TS dt 0.0001 time 0.0371\n372 TS dt 0.0001 time 0.0372\n373 TS dt 0.0001 time 0.0373\n374 TS dt 0.0001 time 0.0374\n375 TS dt 0.0001 time 0.0375\n376 TS dt 0.0001 time 0.0376\n377 TS dt 0.0001 time 0.0377\n378 TS dt 0.0001 time 0.0378\n379 TS dt 0.0001 time 0.0379\n380 TS dt 0.0001 time 0.038\n381 TS dt 0.0001 time 0.0381\n382 TS dt 0.0001 time 0.0382\n383 TS dt 0.0001 time 0.0383\n384 TS dt 0.0001 time 0.0384\n385 TS dt 0.0001 time 0.0385\n386 TS dt 0.0001 time 0.0386\n387 TS dt 0.0001 time 0.0387\n388 TS dt 0.0001 time 0.0388\n389 TS dt 0.0001 time 0.0389\n390 TS dt 0.0001 time 0.039\n391 TS dt 0.0001 time 0.0391\n392 TS dt 0.0001 time 0.0392\n393 TS dt 0.0001 time 0.0393\n394 TS dt 0.0001 time 0.0394\n395 TS dt 0.0001 time 0.0395\n396 TS dt 0.0001 time 0.0396\n397 TS dt 0.0001 time 0.0397\n398 TS dt 0.0001 time 0.0398\n399 TS dt 0.0001 time 0.0399\n400 TS dt 0.0001 time 0.04\n401 TS dt 0.0001 time 0.0401\n402 TS dt 0.0001 time 0.0402\n403 TS dt 0.0001 time 0.0403\n404 TS dt 0.0001 time 0.0404\n405 TS dt 0.0001 time 0.0405\n406 TS dt 0.0001 time 0.0406\n407 TS dt 0.0001 time 0.0407\n408 TS dt 0.0001 time 0.0408\n409 TS dt 0.0001 time 0.0409\n410 TS dt 0.0001 time 0.041\n411 TS dt 0.0001 time 0.0411\n412 TS dt 0.0001 time 0.0412\n413 TS dt 0.0001 time 0.0413\n414 TS dt 0.0001 time 0.0414\n415 TS dt 0.0001 time 0.0415\n416 TS dt 0.0001 time 0.0416\n417 TS dt 0.0001 time 0.0417\n418 TS dt 0.0001 time 0.0418\n419 TS dt 0.0001 time 0.0419\n420 TS dt 0.0001 time 0.042\n421 TS dt 0.0001 time 0.0421\n422 TS dt 0.0001 time 0.0422\n423 TS dt 0.0001 time 0.0423\n424 TS dt 0.0001 time 0.0424\n425 TS dt 0.0001 time 0.0425\n426 TS dt 0.0001 time 0.0426\n427 TS dt 0.0001 time 0.0427\n428 TS dt 0.0001 time 0.0428\n429 TS dt 0.0001 time 0.0429\n430 TS dt 0.0001 time 0.043\n431 TS dt 0.0001 time 0.0431\n432 TS dt 0.0001 time 0.0432\n433 TS dt 0.0001 time 0.0433\n434 TS dt 0.0001 time 0.0434\n435 TS dt 0.0001 time 0.0435\n436 TS dt 0.0001 time 0.0436\n437 TS dt 0.0001 time 0.0437\n438 TS dt 0.0001 time 0.0438\n439 TS dt 0.0001 time 0.0439\n440 TS dt 0.0001 time 0.044\n441 TS dt 0.0001 time 0.0441\n442 TS dt 0.0001 time 0.0442\n443 TS dt 0.0001 time 0.0443\n444 TS dt 0.0001 time 0.0444\n445 TS dt 0.0001 time 0.0445\n446 TS dt 0.0001 time 0.0446\n447 TS dt 0.0001 time 0.0447\n448 TS dt 0.0001 time 0.0448\n449 TS dt 0.0001 time 0.0449\n450 TS dt 0.0001 time 0.045\n451 TS dt 0.0001 time 0.0451\n452 TS dt 0.0001 time 0.0452\n453 TS dt 0.0001 time 0.0453\n454 TS dt 0.0001 time 0.0454\n455 TS dt 0.0001 time 0.0455\n456 TS dt 0.0001 time 0.0456\n457 TS dt 0.0001 time 0.0457\n458 TS dt 0.0001 time 0.0458\n459 TS dt 0.0001 time 0.0459\n460 TS dt 0.0001 time 0.046\n461 TS dt 0.0001 time 0.0461\n462 TS dt 0.0001 time 0.0462\n463 TS dt 0.0001 time 0.0463\n464 TS dt 0.0001 time 0.0464\n465 TS dt 0.0001 time 0.0465\n466 TS dt 0.0001 time 0.0466\n467 TS dt 0.0001 time 0.0467\n468 TS dt 0.0001 time 0.0468\n469 TS dt 0.0001 time 0.0469\n470 TS dt 0.0001 time 0.047\n471 TS dt 0.0001 time 0.0471\n472 TS dt 0.0001 time 0.0472\n473 TS dt 0.0001 time 0.0473\n474 TS dt 0.0001 time 0.0474\n475 TS dt 0.0001 time 0.0475\n476 TS dt 0.0001 time 0.0476\n477 TS dt 0.0001 time 0.0477\n478 TS dt 0.0001 time 0.0478\n479 TS dt 0.0001 time 0.0479\n480 TS dt 0.0001 time 0.048\n481 TS dt 0.0001 time 0.0481\n482 TS dt 0.0001 time 0.0482\n483 TS dt 0.0001 time 0.0483\n484 TS dt 0.0001 time 0.0484\n485 TS dt 0.0001 time 0.0485\n486 TS dt 0.0001 time 0.0486\n487 TS dt 0.0001 time 0.0487\n488 TS dt 0.0001 time 0.0488\n489 TS dt 0.0001 time 0.0489\n490 TS dt 0.0001 time 0.049\n491 TS dt 0.0001 time 0.0491\n492 TS dt 0.0001 time 0.0492\n493 TS dt 0.0001 time 0.0493\n494 TS dt 0.0001 time 0.0494\n495 TS dt 0.0001 time 0.0495\n496 TS dt 0.0001 time 0.0496\n497 TS dt 0.0001 time 0.0497\n498 TS dt 0.0001 time 0.0498\n499 TS dt 0.0001 time 0.0499\n500 TS dt 0.0001 time 0.05\n501 TS dt 0.0001 time 0.0501\n502 TS dt 0.0001 time 0.0502\n503 TS dt 0.0001 time 0.0503\n504 TS dt 0.0001 time 0.0504\n505 TS dt 0.0001 time 0.0505\n506 TS dt 0.0001 time 0.0506\n507 TS dt 0.0001 time 0.0507\n508 TS dt 0.0001 time 0.0508\n509 TS dt 0.0001 time 0.0509\n510 TS dt 0.0001 time 0.051\n511 TS dt 0.0001 time 0.0511\n512 TS dt 0.0001 time 0.0512\n513 TS dt 0.0001 time 0.0513\n514 TS dt 0.0001 time 0.0514\n515 TS dt 0.0001 time 0.0515\n516 TS dt 0.0001 time 0.0516\n517 TS dt 0.0001 time 0.0517\n518 TS dt 0.0001 time 0.0518\n519 TS dt 0.0001 time 0.0519\n520 TS dt 0.0001 time 0.052\n521 TS dt 0.0001 time 0.0521\n522 TS dt 0.0001 time 0.0522\n523 TS dt 0.0001 time 0.0523\n524 TS dt 0.0001 time 0.0524\n525 TS dt 0.0001 time 0.0525\n526 TS dt 0.0001 time 0.0526\n527 TS dt 0.0001 time 0.0527\n528 TS dt 0.0001 time 0.0528\n529 TS dt 0.0001 time 0.0529\n530 TS dt 0.0001 time 0.053\n531 TS dt 0.0001 time 0.0531\n532 TS dt 0.0001 time 0.0532\n533 TS dt 0.0001 time 0.0533\n534 TS dt 0.0001 time 0.0534\n535 TS dt 0.0001 time 0.0535\n536 TS dt 0.0001 time 0.0536\n537 TS dt 0.0001 time 0.0537\n538 TS dt 0.0001 time 0.0538\n539 TS dt 0.0001 time 0.0539\n540 TS dt 0.0001 time 0.054\n541 TS dt 0.0001 time 0.0541\n542 TS dt 0.0001 time 0.0542\n543 TS dt 0.0001 time 0.0543\n544 TS dt 0.0001 time 0.0544\n545 TS dt 0.0001 time 0.0545\n546 TS dt 0.0001 time 0.0546\n547 TS dt 0.0001 time 0.0547\n548 TS dt 0.0001 time 0.0548\n549 TS dt 0.0001 time 0.0549\n550 TS dt 0.0001 time 0.055\n551 TS dt 0.0001 time 0.0551\n552 TS dt 0.0001 time 0.0552\n553 TS dt 0.0001 time 0.0553\n554 TS dt 0.0001 time 0.0554\n555 TS dt 0.0001 time 0.0555\n556 TS dt 0.0001 time 0.0556\n557 TS dt 0.0001 time 0.0557\n558 TS dt 0.0001 time 0.0558\n559 TS dt 0.0001 time 0.0559\n560 TS dt 0.0001 time 0.056\n561 TS dt 0.0001 time 0.0561\n562 TS dt 0.0001 time 0.0562\n563 TS dt 0.0001 time 0.0563\n564 TS dt 0.0001 time 0.0564\n565 TS dt 0.0001 time 0.0565\n566 TS dt 0.0001 time 0.0566\n567 TS dt 0.0001 time 0.0567\n568 TS dt 0.0001 time 0.0568\n569 TS dt 0.0001 time 0.0569\n570 TS dt 0.0001 time 0.057\n571 TS dt 0.0001 time 0.0571\n572 TS dt 0.0001 time 0.0572\n573 TS dt 0.0001 time 0.0573\n574 TS dt 0.0001 time 0.0574\n575 TS dt 0.0001 time 0.0575\n576 TS dt 0.0001 time 0.0576\n577 TS dt 0.0001 time 0.0577\n578 TS dt 0.0001 time 0.0578\n579 TS dt 0.0001 time 0.0579\n580 TS dt 0.0001 time 0.058\n581 TS dt 0.0001 time 0.0581\n582 TS dt 0.0001 time 0.0582\n583 TS dt 0.0001 time 0.0583\n584 TS dt 0.0001 time 0.0584\n585 TS dt 0.0001 time 0.0585\n586 TS dt 0.0001 time 0.0586\n587 TS dt 0.0001 time 0.0587\n588 TS dt 0.0001 time 0.0588\n589 TS dt 0.0001 time 0.0589\n590 TS dt 0.0001 time 0.059\n591 TS dt 0.0001 time 0.0591\n592 TS dt 0.0001 time 0.0592\n593 TS dt 0.0001 time 0.0593\n594 TS dt 0.0001 time 0.0594\n595 TS dt 0.0001 time 0.0595\n596 TS dt 0.0001 time 0.0596\n597 TS dt 0.0001 time 0.0597\n598 TS dt 0.0001 time 0.0598\n599 TS dt 0.0001 time 0.0599\n600 TS dt 0.0001 time 0.06\n601 TS dt 0.0001 time 0.0601\n602 TS dt 0.0001 time 0.0602\n603 TS dt 0.0001 time 0.0603\n604 TS dt 0.0001 time 0.0604\n605 TS dt 0.0001 time 0.0605\n606 TS dt 0.0001 time 0.0606\n607 TS dt 0.0001 time 0.0607\n608 TS dt 0.0001 time 0.0608\n609 TS dt 0.0001 time 0.0609\n610 TS dt 0.0001 time 0.061\n611 TS dt 0.0001 time 0.0611\n612 TS dt 0.0001 time 0.0612\n613 TS dt 0.0001 time 0.0613\n614 TS dt 0.0001 time 0.0614\n615 TS dt 0.0001 time 0.0615\n616 TS dt 0.0001 time 0.0616\n617 TS dt 0.0001 time 0.0617\n618 TS dt 0.0001 time 0.0618\n619 TS dt 0.0001 time 0.0619\n620 TS dt 0.0001 time 0.062\n621 TS dt 0.0001 time 0.0621\n622 TS dt 0.0001 time 0.0622\n623 TS dt 0.0001 time 0.0623\n624 TS dt 0.0001 time 0.0624\n625 TS dt 0.0001 time 0.0625\n626 TS dt 0.0001 time 0.0626\n627 TS dt 0.0001 time 0.0627\n628 TS dt 0.0001 time 0.0628\n629 TS dt 0.0001 time 0.0629\n630 TS dt 0.0001 time 0.063\n631 TS dt 0.0001 time 0.0631\n632 TS dt 0.0001 time 0.0632\n633 TS dt 0.0001 time 0.0633\n634 TS dt 0.0001 time 0.0634\n635 TS dt 0.0001 time 0.0635\n636 TS dt 0.0001 time 0.0636\n637 TS dt 0.0001 time 0.0637\n638 TS dt 0.0001 time 0.0638\n639 TS dt 0.0001 time 0.0639\n640 TS dt 0.0001 time 0.064\n641 TS dt 0.0001 time 0.0641\n642 TS dt 0.0001 time 0.0642\n643 TS dt 0.0001 time 0.0643\n644 TS dt 0.0001 time 0.0644\n645 TS dt 0.0001 time 0.0645\n646 TS dt 0.0001 time 0.0646\n647 TS dt 0.0001 time 0.0647\n648 TS dt 0.0001 time 0.0648\n649 TS dt 0.0001 time 0.0649\n650 TS dt 0.0001 time 0.065\n651 TS dt 0.0001 time 0.0651\n652 TS dt 0.0001 time 0.0652\n653 TS dt 0.0001 time 0.0653\n654 TS dt 0.0001 time 0.0654\n655 TS dt 0.0001 time 0.0655\n656 TS dt 0.0001 time 0.0656\n657 TS dt 0.0001 time 0.0657\n658 TS dt 0.0001 time 0.0658\n659 TS dt 0.0001 time 0.0659\n660 TS dt 0.0001 time 0.066\n661 TS dt 0.0001 time 0.0661\n662 TS dt 0.0001 time 0.0662\n663 TS dt 0.0001 time 0.0663\n664 TS dt 0.0001 time 0.0664\n665 TS dt 0.0001 time 0.0665\n666 TS dt 0.0001 time 0.0666\n667 TS dt 0.0001 time 0.0667\n668 TS dt 0.0001 time 0.0668\n669 TS dt 0.0001 time 0.0669\n670 TS dt 0.0001 time 0.067\n671 TS dt 0.0001 time 0.0671\n672 TS dt 0.0001 time 0.0672\n673 TS dt 0.0001 time 0.0673\n674 TS dt 0.0001 time 0.0674\n675 TS dt 0.0001 time 0.0675\n676 TS dt 0.0001 time 0.0676\n677 TS dt 0.0001 time 0.0677\n678 TS dt 0.0001 time 0.0678\n679 TS dt 0.0001 time 0.0679\n680 TS dt 0.0001 time 0.068\n681 TS dt 0.0001 time 0.0681\n682 TS dt 0.0001 time 0.0682\n683 TS dt 0.0001 time 0.0683\n684 TS dt 0.0001 time 0.0684\n685 TS dt 0.0001 time 0.0685\n686 TS dt 0.0001 time 0.0686\n687 TS dt 0.0001 time 0.0687\n688 TS dt 0.0001 time 0.0688\n689 TS dt 0.0001 time 0.0689\n690 TS dt 0.0001 time 0.069\n691 TS dt 0.0001 time 0.0691\n692 TS dt 0.0001 time 0.0692\n693 TS dt 0.0001 time 0.0693\n694 TS dt 0.0001 time 0.0694\n695 TS dt 0.0001 time 0.0695\n696 TS dt 0.0001 time 0.0696\n697 TS dt 0.0001 time 0.0697\n698 TS dt 0.0001 time 0.0698\n699 TS dt 0.0001 time 0.0699\n700 TS dt 0.0001 time 0.07\n701 TS dt 0.0001 time 0.0701\n702 TS dt 0.0001 time 0.0702\n703 TS dt 0.0001 time 0.0703\n704 TS dt 0.0001 time 0.0704\n705 TS dt 0.0001 time 0.0705\n706 TS dt 0.0001 time 0.0706\n707 TS dt 0.0001 time 0.0707\n708 TS dt 0.0001 time 0.0708\n709 TS dt 0.0001 time 0.0709\n710 TS dt 0.0001 time 0.071\n711 TS dt 0.0001 time 0.0711\n712 TS dt 0.0001 time 0.0712\n713 TS dt 0.0001 time 0.0713\n714 TS dt 0.0001 time 0.0714\n715 TS dt 0.0001 time 0.0715\n716 TS dt 0.0001 time 0.0716\n717 TS dt 0.0001 time 0.0717\n718 TS dt 0.0001 time 0.0718\n719 TS dt 0.0001 time 0.0719\n720 TS dt 0.0001 time 0.072\n721 TS dt 0.0001 time 0.0721\n722 TS dt 0.0001 time 0.0722\n723 TS dt 0.0001 time 0.0723\n724 TS dt 0.0001 time 0.0724\n725 TS dt 0.0001 time 0.0725\n726 TS dt 0.0001 time 0.0726\n727 TS dt 0.0001 time 0.0727\n728 TS dt 0.0001 time 0.0728\n729 TS dt 0.0001 time 0.0729\n730 TS dt 0.0001 time 0.073\n731 TS dt 0.0001 time 0.0731\n732 TS dt 0.0001 time 0.0732\n733 TS dt 0.0001 time 0.0733\n734 TS dt 0.0001 time 0.0734\n735 TS dt 0.0001 time 0.0735\n736 TS dt 0.0001 time 0.0736\n737 TS dt 0.0001 time 0.0737\n738 TS dt 0.0001 time 0.0738\n739 TS dt 0.0001 time 0.0739\n740 TS dt 0.0001 time 0.074\n741 TS dt 0.0001 time 0.0741\n742 TS dt 0.0001 time 0.0742\n743 TS dt 0.0001 time 0.0743\n744 TS dt 0.0001 time 0.0744\n745 TS dt 0.0001 time 0.0745\n746 TS dt 0.0001 time 0.0746\n747 TS dt 0.0001 time 0.0747\n748 TS dt 0.0001 time 0.0748\n749 TS dt 0.0001 time 0.0749\n750 TS dt 0.0001 time 0.075\n751 TS dt 0.0001 time 0.0751\n752 TS dt 0.0001 time 0.0752\n753 TS dt 0.0001 time 0.0753\n754 TS dt 0.0001 time 0.0754\n755 TS dt 0.0001 time 0.0755\n756 TS dt 0.0001 time 0.0756\n757 TS dt 0.0001 time 0.0757\n758 TS dt 0.0001 time 0.0758\n759 TS dt 0.0001 time 0.0759\n760 TS dt 0.0001 time 0.076\n761 TS dt 0.0001 time 0.0761\n762 TS dt 0.0001 time 0.0762\n763 TS dt 0.0001 time 0.0763\n764 TS dt 0.0001 time 0.0764\n765 TS dt 0.0001 time 0.0765\n766 TS dt 0.0001 time 0.0766\n767 TS dt 0.0001 time 0.0767\n768 TS dt 0.0001 time 0.0768\n769 TS dt 0.0001 time 0.0769\n770 TS dt 0.0001 time 0.077\n771 TS dt 0.0001 time 0.0771\n772 TS dt 0.0001 time 0.0772\n773 TS dt 0.0001 time 0.0773\n774 TS dt 0.0001 time 0.0774\n775 TS dt 0.0001 time 0.0775\n776 TS dt 0.0001 time 0.0776\n777 TS dt 0.0001 time 0.0777\n778 TS dt 0.0001 time 0.0778\n779 TS dt 0.0001 time 0.0779\n780 TS dt 0.0001 time 0.078\n781 TS dt 0.0001 time 0.0781\n782 TS dt 0.0001 time 0.0782\n783 TS dt 0.0001 time 0.0783\n784 TS dt 0.0001 time 0.0784\n785 TS dt 0.0001 time 0.0785\n786 TS dt 0.0001 time 0.0786\n787 TS dt 0.0001 time 0.0787\n788 TS dt 0.0001 time 0.0788\n789 TS dt 0.0001 time 0.0789\n790 TS dt 0.0001 time 0.079\n791 TS dt 0.0001 time 0.0791\n792 TS dt 0.0001 time 0.0792\n793 TS dt 0.0001 time 0.0793\n794 TS dt 0.0001 time 0.0794\n795 TS dt 0.0001 time 0.0795\n796 TS dt 0.0001 time 0.0796\n797 TS dt 0.0001 time 0.0797\n798 TS dt 0.0001 time 0.0798\n799 TS dt 0.0001 time 0.0799\n800 TS dt 0.0001 time 0.08\n801 TS dt 0.0001 time 0.0801\n802 TS dt 0.0001 time 0.0802\n803 TS dt 0.0001 time 0.0803\n804 TS dt 0.0001 time 0.0804\n805 TS dt 0.0001 time 0.0805\n806 TS dt 0.0001 time 0.0806\n807 TS dt 0.0001 time 0.0807\n808 TS dt 0.0001 time 0.0808\n809 TS dt 0.0001 time 0.0809\n810 TS dt 0.0001 time 0.081\n811 TS dt 0.0001 time 0.0811\n812 TS dt 0.0001 time 0.0812\n813 TS dt 0.0001 time 0.0813\n814 TS dt 0.0001 time 0.0814\n815 TS dt 0.0001 time 0.0815\n816 TS dt 0.0001 time 0.0816\n817 TS dt 0.0001 time 0.0817\n818 TS dt 0.0001 time 0.0818\n819 TS dt 0.0001 time 0.0819\n820 TS dt 0.0001 time 0.082\n821 TS dt 0.0001 time 0.0821\n822 TS dt 0.0001 time 0.0822\n823 TS dt 0.0001 time 0.0823\n824 TS dt 0.0001 time 0.0824\n825 TS dt 0.0001 time 0.0825\n826 TS dt 0.0001 time 0.0826\n827 TS dt 0.0001 time 0.0827\n828 TS dt 0.0001 time 0.0828\n829 TS dt 0.0001 time 0.0829\n830 TS dt 0.0001 time 0.083\n831 TS dt 0.0001 time 0.0831\n832 TS dt 0.0001 time 0.0832\n833 TS dt 0.0001 time 0.0833\n834 TS dt 0.0001 time 0.0834\n835 TS dt 0.0001 time 0.0835\n836 TS dt 0.0001 time 0.0836\n837 TS dt 0.0001 time 0.0837\n838 TS dt 0.0001 time 0.0838\n839 TS dt 0.0001 time 0.0839\n840 TS dt 0.0001 time 0.084\n841 TS dt 0.0001 time 0.0841\n842 TS dt 0.0001 time 0.0842\n843 TS dt 0.0001 time 0.0843\n844 TS dt 0.0001 time 0.0844\n845 TS dt 0.0001 time 0.0845\n846 TS dt 0.0001 time 0.0846\n847 TS dt 0.0001 time 0.0847\n848 TS dt 0.0001 time 0.0848\n849 TS dt 0.0001 time 0.0849\n850 TS dt 0.0001 time 0.085\n851 TS dt 0.0001 time 0.0851\n852 TS dt 0.0001 time 0.0852\n853 TS dt 0.0001 time 0.0853\n854 TS dt 0.0001 time 0.0854\n855 TS dt 0.0001 time 0.0855\n856 TS dt 0.0001 time 0.0856\n857 TS dt 0.0001 time 0.0857\n858 TS dt 0.0001 time 0.0858\n859 TS dt 0.0001 time 0.0859\n860 TS dt 0.0001 time 0.086\n861 TS dt 0.0001 time 0.0861\n862 TS dt 0.0001 time 0.0862\n863 TS dt 0.0001 time 0.0863\n864 TS dt 0.0001 time 0.0864\n865 TS dt 0.0001 time 0.0865\n866 TS dt 0.0001 time 0.0866\n867 TS dt 0.0001 time 0.0867\n868 TS dt 0.0001 time 0.0868\n869 TS dt 0.0001 time 0.0869\n870 TS dt 0.0001 time 0.087\n871 TS dt 0.0001 time 0.0871\n872 TS dt 0.0001 time 0.0872\n873 TS dt 0.0001 time 0.0873\n874 TS dt 0.0001 time 0.0874\n875 TS dt 0.0001 time 0.0875\n876 TS dt 0.0001 time 0.0876\n877 TS dt 0.0001 time 0.0877\n878 TS dt 0.0001 time 0.0878\n879 TS dt 0.0001 time 0.0879\n880 TS dt 0.0001 time 0.088\n881 TS dt 0.0001 time 0.0881\n882 TS dt 0.0001 time 0.0882\n883 TS dt 0.0001 time 0.0883\n884 TS dt 0.0001 time 0.0884\n885 TS dt 0.0001 time 0.0885\n886 TS dt 0.0001 time 0.0886\n887 TS dt 0.0001 time 0.0887\n888 TS dt 0.0001 time 0.0888\n889 TS dt 0.0001 time 0.0889\n890 TS dt 0.0001 time 0.089\n891 TS dt 0.0001 time 0.0891\n892 TS dt 0.0001 time 0.0892\n893 TS dt 0.0001 time 0.0893\n894 TS dt 0.0001 time 0.0894\n895 TS dt 0.0001 time 0.0895\n896 TS dt 0.0001 time 0.0896\n897 TS dt 0.0001 time 0.0897\n898 TS dt 0.0001 time 0.0898\n899 TS dt 0.0001 time 0.0899\n900 TS dt 0.0001 time 0.09\n901 TS dt 0.0001 time 0.0901\n902 TS dt 0.0001 time 0.0902\n903 TS dt 0.0001 time 0.0903\n904 TS dt 0.0001 time 0.0904\n905 TS dt 0.0001 time 0.0905\n906 TS dt 0.0001 time 0.0906\n907 TS dt 0.0001 time 0.0907\n908 TS dt 0.0001 time 0.0908\n909 TS dt 0.0001 time 0.0909\n910 TS dt 0.0001 time 0.091\n911 TS dt 0.0001 time 0.0911\n912 TS dt 0.0001 time 0.0912\n913 TS dt 0.0001 time 0.0913\n914 TS dt 0.0001 time 0.0914\n915 TS dt 0.0001 time 0.0915\n916 TS dt 0.0001 time 0.0916\n917 TS dt 0.0001 time 0.0917\n918 TS dt 0.0001 time 0.0918\n919 TS dt 0.0001 time 0.0919\n920 TS dt 0.0001 time 0.092\n921 TS dt 0.0001 time 0.0921\n922 TS dt 0.0001 time 0.0922\n923 TS dt 0.0001 time 0.0923\n924 TS dt 0.0001 time 0.0924\n925 TS dt 0.0001 time 0.0925\n926 TS dt 0.0001 time 0.0926\n927 TS dt 0.0001 time 0.0927\n928 TS dt 0.0001 time 0.0928\n929 TS dt 0.0001 time 0.0929\n930 TS dt 0.0001 time 0.093\n931 TS dt 0.0001 time 0.0931\n932 TS dt 0.0001 time 0.0932\n933 TS dt 0.0001 time 0.0933\n934 TS dt 0.0001 time 0.0934\n935 TS dt 0.0001 time 0.0935\n936 TS dt 0.0001 time 0.0936\n937 TS dt 0.0001 time 0.0937\n938 TS dt 0.0001 time 0.0938\n939 TS dt 0.0001 time 0.0939\n940 TS dt 0.0001 time 0.094\n941 TS dt 0.0001 time 0.0941\n942 TS dt 0.0001 time 0.0942\n943 TS dt 0.0001 time 0.0943\n944 TS dt 0.0001 time 0.0944\n945 TS dt 0.0001 time 0.0945\n946 TS dt 0.0001 time 0.0946\n947 TS dt 0.0001 time 0.0947\n948 TS dt 0.0001 time 0.0948\n949 TS dt 0.0001 time 0.0949\n950 TS dt 0.0001 time 0.095\n951 TS dt 0.0001 time 0.0951\n952 TS dt 0.0001 time 0.0952\n953 TS dt 0.0001 time 0.0953\n954 TS dt 0.0001 time 0.0954\n955 TS dt 0.0001 time 0.0955\n956 TS dt 0.0001 time 0.0956\n957 TS dt 0.0001 time 0.0957\n958 TS dt 0.0001 time 0.0958\n959 TS dt 0.0001 time 0.0959\n960 TS dt 0.0001 time 0.096\n961 TS dt 0.0001 time 0.0961\n962 TS dt 0.0001 time 0.0962\n963 TS dt 0.0001 time 0.0963\n964 TS dt 0.0001 time 0.0964\n965 TS dt 0.0001 time 0.0965\n966 TS dt 0.0001 time 0.0966\n967 TS dt 0.0001 time 0.0967\n968 TS dt 0.0001 time 0.0968\n969 TS dt 0.0001 time 0.0969\n970 TS dt 0.0001 time 0.097\n971 TS dt 0.0001 time 0.0971\n972 TS dt 0.0001 time 0.0972\n973 TS dt 0.0001 time 0.0973\n974 TS dt 0.0001 time 0.0974\n975 TS dt 0.0001 time 0.0975\n976 TS dt 0.0001 time 0.0976\n977 TS dt 0.0001 time 0.0977\n978 TS dt 0.0001 time 0.0978\n979 TS dt 0.0001 time 0.0979\n980 TS dt 0.0001 time 0.098\n981 TS dt 0.0001 time 0.0981\n982 TS dt 0.0001 time 0.0982\n983 TS dt 0.0001 time 0.0983\n984 TS dt 0.0001 time 0.0984\n985 TS dt 0.0001 time 0.0985\n986 TS dt 0.0001 time 0.0986\n987 TS dt 0.0001 time 0.0987\n988 TS dt 0.0001 time 0.0988\n989 TS dt 0.0001 time 0.0989\n990 TS dt 0.0001 time 0.099\n991 TS dt 0.0001 time 0.0991\n992 TS dt 0.0001 time 0.0992\n993 TS dt 0.0001 time 0.0993\n994 TS dt 0.0001 time 0.0994\n995 TS dt 0.0001 time 0.0995\n996 TS dt 0.0001 time 0.0996\n997 TS dt 0.0001 time 0.0997\n998 TS dt 0.0001 time 0.0998\n999 TS dt 0.0001 time 0.0999\n1000 TS dt 0.0001 time 0.1\nVec Object: 1 MPI process\n  type: seq\n0.996078\n3.58044e-05\n0.00388645\n",
      "stderr": "",
      "cli_args": "-ts_monitor",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic Robertson_ODE.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o Robertson_ODE\n",
      "compile_stderr": "",
      "composite_score": 36.09884639803346,
      "tier": "FAIL",
      "category_scores": {
        "correctness": 1.27963e-319,
        "performance": 76.36993169784544,
        "code_quality": 60.00000000000001,
        "algorithm": 49.743589743589745,
        "petsc": 81.81818181818183
      },
      "evaluation_summary": {
        "total_evaluators": 14,
        "passed_evaluators": 9,
        "failed_evaluators": 5,
        "all_gates_passed": true,
        "gates_passed": 4,
        "gates_total": 4
      },
      "evaluation_details": [
        {
          "name": "compilation",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code compiled successfully"
        },
        {
          "name": "execution",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code executed successfully"
        },
        {
          "name": "memory_safety",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 0.7,
          "feedback": "Basic memory safety check (valgrind not available)"
        },
        {
          "name": "api_usage",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "All basic PETSc API requirements met"
        },
        {
          "name": "numerical_accuracy",
          "type": "metric",
          "method": "deterministic",
          "passed": false,
          "score": 1.28e-321,
          "raw_value": 0.7388816265396255,
          "confidence": 1.0,
          "feedback": "Poor accuracy: error = 7.39e-01 (threshold: 1.00e-03)"
        },
        {
          "name": "execution_time",
          "type": "metric",
          "method": "deterministic",
          "passed": true,
          "score": 0.7636993169784545,
          "raw_value": 6.8150341510772705,
          "confidence": 1.0,
          "feedback": "Acceptable performance: 6.815s (5.0s - 15.0s)"
        },
        {
          "name": "error_handling",
          "type": "quality",
          "method": "deterministic",
          "passed": true,
          "score": 1.0,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Excellent error handling: 25 CHKERRQ calls"
        },
        {
          "name": "parallel_awareness",
          "type": "quality",
          "method": "deterministic",
          "passed": true,
          "score": 0.85,
          "raw_value": null,
          "confidence": 0.8,
          "feedback": "Parallel features: Uses PETSC_COMM_WORLD, Parallel-aware sizing"
        },
        {
          "name": "readability",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.8,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code is highly readable and follows standard PETSc idioms. It is concise and logically structured, though it lacks internal documentation for the physics and uses slightly generic variable names for the ODE components."
        },
        {
          "name": "code_style",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.8,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code is functional and generally follows PETSc's object-oriented C style, but it uses deprecated error handling macros and lacks modern PETSc formatting standards."
        },
        {
          "name": "documentation",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.2,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code is largely self-documenting for PETSc experts but lacks formal documentation. There is a single header comment identifying the problem, but no function-level documentation (Doxygen style or otherwise) explaining parameters or return values. There are no inline comments explaining the physics of the Robertson ODE or the specific PETSc configuration choices made in the main function."
        },
        {
          "name": "algorithm_appropriateness",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.6,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The Robertson problem is a classic benchmark for 'stiff' ODE systems, characterized by reaction rates spanning several orders of magnitude (0.04 to 3e7). While the code correctly uses the PETSc TS (Time Stepper) framework and an implicit formulation (IFunction), the choice of the Crank-Nicolson (TSCN) method is suboptimal. Crank-Nicolson is A-stable but not L-stable, meaning it can exhibit undamped oscillations when solving highly stiff problems. Furthermore, the code lacks an IJacobian implementation; while PETSc can approximate this via finite differences, providing an analytical Jacobian is standard practice for such stiff systems to ensure solver robustness. The provided code is also syntactically incomplete (truncated at the end)."
        },
        {
          "name": "solver_choice",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.4,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The code correctly identifies the TS (Time Stepper) framework for an ODE problem. However, the specific choice of the Crank-Nicolson (TSCN) method is poor for the Robertson problem. This problem is a classic example of a 'stiff' ODE system, characterized by reaction rates spanning several orders of magnitude (0.04 to 3e7). TSCN is an A-stable method but lacks L-stability, meaning it can suffer from persistent oscillations when dealing with very stiff systems. Furthermore, the code lacks a Jacobian implementation (TSSetIJacobian), which is critical for the Newton-type solvers used in implicit methods to converge efficiently on stiff problems. The step limit (1000) is also likely too low for a fixed-step or poorly-tuned TSCN to reach t=100 accurately."
        },
        {
          "name": "petsc_best_practices",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.6,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code correctly implements the core PETSc TS (Time-Stepping) interface and uses the recommended IFunction approach for implicit ODEs. It properly utilizes VecSetFromOptions and TSSetFromOptions, which allows for runtime configuration of solvers and methods. However, it lacks several best practices: it does not use PetscViewer for output (the results are not displayed or saved), it hardcodes the initial conditions and parameters instead of allowing them to be set via the options database (PetscOptionsGetScalar), and it uses the deprecated CHKERRQ macro instead of the modern PetscCall. Additionally, the code is truncated at the end."
        }
      ]
    },
    {
      "problem_name": "scatter_vecmpi",
      "problem_id": "4",
      "runs": true,
      "time_used_sec": 12.942974328994751,
      "compiles": true,
      "stdout": "Gathered vector on rank 0:\nVec Object: 1 MPI process\n  type: seq\n2.\n4.\n6.\n8.\n10.\n12.\n14.\n16.\n18.\n20.\n",
      "stderr": "",
      "cli_args": "-N 10",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic scatter_vecmpi.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o scatter_vecmpi\n",
      "compile_stderr": "scatter_vecmpi.c: In function \u2018main\u2019:\nscatter_vecmpi.c:6:36: warning: unused variable \u2018local_size\u2019 [-Wunused-variable]\n    6 |     PetscInt n = 10, i, low, high, local_size;\n      |                                    ^~~~~~~~~~\n",
      "composite_score": 76.8395509668483,
      "tier": "SILVER",
      "category_scores": {
        "correctness": 100.0,
        "performance": 64.1140513420105,
        "code_quality": 70.17241379310346,
        "algorithm": 85.38461538461539,
        "petsc": 88.8888888888889
      },
      "evaluation_summary": {
        "total_evaluators": 14,
        "passed_evaluators": 12,
        "failed_evaluators": 1,
        "all_gates_passed": true,
        "gates_passed": 4,
        "gates_total": 4
      },
      "evaluation_details": [
        {
          "name": "compilation",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code compiled successfully"
        },
        {
          "name": "execution",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Code executed successfully"
        },
        {
          "name": "memory_safety",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 0.7,
          "feedback": "Basic memory safety check (valgrind not available)"
        },
        {
          "name": "api_usage",
          "type": "gate",
          "method": "deterministic",
          "passed": true,
          "score": null,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "All basic PETSc API requirements met"
        },
        {
          "name": "numerical_accuracy",
          "type": "metric",
          "method": "deterministic",
          "passed": true,
          "score": 1.0,
          "raw_value": 0.0,
          "confidence": 1.0,
          "feedback": "Excellent accuracy: error = 0.00e+00 (threshold: 1.00e-03)"
        },
        {
          "name": "execution_time",
          "type": "metric",
          "method": "deterministic",
          "passed": true,
          "score": 0.6411405134201049,
          "raw_value": 12.942974328994751,
          "confidence": 1.0,
          "feedback": "Acceptable performance: 12.943s (5.0s - 15.0s)"
        },
        {
          "name": "error_handling",
          "type": "quality",
          "method": "deterministic",
          "passed": true,
          "score": 0.8,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "Good error handling: 23 CHKERRQ calls"
        },
        {
          "name": "parallel_awareness",
          "type": "quality",
          "method": "deterministic",
          "passed": true,
          "score": 1.0,
          "raw_value": null,
          "confidence": 0.8,
          "feedback": "Parallel features: Uses PETSC_COMM_WORLD, Rank-aware code, Parallel-aware sizing"
        },
        {
          "name": "readability",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.8,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The code is highly readable and follows standard PETSc idioms. It is well-structured with clear logical phases (initialization, computation, communication, and cleanup). The score is slightly reduced due to the use of legacy error handling macros and a minor inconsistency in how the sequential vector is handled across ranks."
        },
        {
          "name": "code_style",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.7,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code correctly uses PETSc types and function naming conventions, but it relies on the deprecated CHKERRQ macro and uses an outdated error handling style compared to modern PETSc standards (PetscCall)."
        },
        {
          "name": "documentation",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": false,
          "score": 0.6,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The code contains helpful inline comments that describe the high-level steps of the PETSc workflow. However, it lacks a formal header block for the main function, and there is no documentation regarding the expected command-line arguments (like -N) or the specific MPI environment requirements. While the logic is clear for a simple test, more complex sections like the VecScatter context creation could benefit from more detailed explanations of the parameters used."
        },
        {
          "name": "algorithm_appropriateness",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 0.7,
          "raw_value": null,
          "confidence": 0.95,
          "feedback": "The approach correctly identifies the core PETSc components: VecCreate, VecSetValues, VecScale, and VecScatter. However, the implementation of the VecScatter is flawed. Specifically, the IS (Index Set) for the scatter is created using PETSC_COMM_SELF with the global size 'n' on all ranks, which will cause memory errors or crashes on non-zero ranks because they attempt to define a local index set larger than their local data. The standard PETSc idiom for gathering to rank 0 is to use VecScatterCreateToZero, which simplifies the logic significantly. Additionally, the code is truncated at the end."
        },
        {
          "name": "solver_choice",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": true,
          "score": 1.0,
          "raw_value": null,
          "confidence": 1.0,
          "feedback": "The problem described is a vector manipulation and communication task, not a system of equations requiring a solver. The code correctly identifies that no KSP, SNES, or TS solver is needed. It uses the appropriate PETSc primitives (Vec, IS, and VecScatter) to perform the requested operations (scaling and gathering). The use of VecScatter is the standard PETSc way to handle data migration between parallel and sequential vectors."
        },
        {
          "name": "petsc_best_practices",
          "type": "quality",
          "method": "llm_gemini/gemini-3-flash-preview",
          "passed": null,
          "score": null,
          "raw_value": null,
          "confidence": 0.0,
          "feedback": "LLM evaluation failed: litellm.InternalServerError: litellm.InternalServerError: geminiException - {\n  \"error\": {\n    \"code\": 503,\n    \"message\": \"The model is overloaded. Please try again later.\",\n    \"status\": \"UNAVAILABLE\"\n  }\n}\n"
        }
      ]
    },
    {
      "problem_name": "NS2D_FV_Implicit",
      "problem_id": "5",
      "runs": false,
      "time_used_sec": 14.666900396347046,
      "compiles": true,
      "stdout": "",
      "stderr": "[0]PETSC ERROR: ------------------------------------------------------------------------\n[0]PETSC ERROR: Caught signal number 11 SEGV: Segmentation Violation, probably memory access out of range\n[0]PETSC ERROR: Try option -start_in_debugger or -on_error_attach_debugger\n[0]PETSC ERROR: or see https://petsc.org/release/faq/#valgrind and https://petsc.org/release/faq/\n[0]PETSC ERROR: configure using --with-debugging=yes, recompile, link, and run \n[0]PETSC ERROR: to get more information on the crash.\n[0]PETSC ERROR: Run with -malloc_debug to check if memory corruption is causing the crash.\napplication called MPI_Abort(MPI_COMM_WORLD, 59) - process 0\n[unset]: PMIU_write error; fd=-1 buf=:cmd=abort exitcode=59 message=abort\n:\nsystem msg for write_line failure : Bad file descriptor\n",
      "cli_args": "-ts_max_steps 10 -snes_atol 1e-6",
      "compile_stdout": "/petsc/arch-linux-x64-opt/bin/mpicc -Wall -Wwrite-strings -Wno-unknown-pragmas -Wno-lto-type-mismatch -Wno-stringop-overflow -fstack-protector -fvisibility=hidden -O2 -march=x86-64  -I/petsc/include -I/petsc/arch-linux-x64-opt/include     -Wl,-export-dynamic NS2D_FV_Implicit.c   -Wl,-rpath,/petsc/arch-linux-x64-opt/lib -L/petsc/arch-linux-x64-opt/lib -lpetsc -lf2clapack -lf2cblas -lm -lX11 -lstdc++  -o NS2D_FV_Implicit\n",
      "compile_stderr": "NS2D_FV_Implicit.c: In function \u2018FormIFunction\u2019:\nNS2D_FV_Implicit.c:35:23: warning: passing argument 2 of \u2018DMDAVecGetArray\u2019 from incompatible pointer type [-Wincompatible-pointer-types]\n   35 |   DMDAVecGetArray(da, f, &f);\n      |                       ^\n      |                       |\n      |                       Field **\nIn file included from NS2D_FV_Implicit.c:7:\n/petsc/include/petscdmda.h:127:49: note: expected \u2018Vec\u2019 {aka \u2018struct _p_Vec *\u2019} but argument is of type \u2018Field **\u2019\n  127 | PETSC_EXTERN PetscErrorCode DMDAVecGetArray(DM, Vec, void *);\n      |                                                 ^~~\nNS2D_FV_Implicit.c:82:27: warning: passing argument 2 of \u2018DMDAVecRestoreArray\u2019 from incompatible pointer type [-Wincompatible-pointer-types]\n   82 |   DMDAVecRestoreArray(da, f, &f);\n      |                           ^\n      |                           |\n      |                           Field **\n/petsc/include/petscdmda.h:128:53: note: expected \u2018Vec\u2019 {aka \u2018struct _p_Vec *\u2019} but argument is of type \u2018Field **\u2019\n  128 | PETSC_EXTERN PetscErrorCode DMDAVecRestoreArray(DM, Vec, void *);\n      |                                                     ^~~\n",
      "composite_score": 0.0,
      "tier": "FAIL",
      "category_scores": null,
      "evaluation_summary": {
        "error": "Exception with tool run_executable: A nonzero returncode 15 from the tool"
      },
      "evaluation_details": null
    }
  ]
}